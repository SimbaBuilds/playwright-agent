#!/usr/bin/env python3
"""
Playwright browser daemon for persistent sessions.
This script runs in the background and processes commands from the main CLI.
"""

import json
import os
import sys
import time
import signal
import base64
from pathlib import Path

# Session files
TEMP_DIR = Path("/tmp/pw-daemon")
COMMAND_FILE = TEMP_DIR / "command.json"
RESULT_FILE = TEMP_DIR / "result.json"
PID_FILE = TEMP_DIR / "daemon.pid"
READY_FILE = TEMP_DIR / "ready"

# Global state
_playwright = None
_browser = None
_page = None
_console_messages = []
_network_requests = []
_running = True
_ref_map = {}  # Maps ref IDs to selectors


def write_result(success: bool, result=None, error=None, snapshot=None):
    """Write result to file."""
    out = {
        "success": success,
        "result": result,
        "error": error
    }
    if snapshot:
        out["snapshot"] = snapshot
    RESULT_FILE.write_text(json.dumps(out, indent=2, default=str))


def handle_signal(signum, frame):
    """Handle shutdown signals."""
    global _running
    _running = False


def init_browser():
    """Initialize browser."""
    global _playwright, _browser, _page

    from playwright.sync_api import sync_playwright

    _playwright = sync_playwright().start()
    _browser = _playwright.chromium.launch(headless=False)
    context = _browser.new_context(viewport={"width": 1280, "height": 720})
    _page = context.new_page()

    # Set up console listener
    def on_console(msg):
        _console_messages.append({
            "type": msg.type,
            "text": msg.text,
            "location": str(msg.location) if msg.location else None
        })
    _page.on("console", on_console)

    # Set up network listener
    def on_request(request):
        _network_requests.append({
            "url": request.url,
            "method": request.method,
            "resource_type": request.resource_type
        })
    _page.on("request", on_request)


def cleanup():
    """Clean up resources."""
    global _browser, _playwright
    if _browser:
        try:
            _browser.close()
        except:
            pass
    if _playwright:
        try:
            _playwright.stop()
        except:
            pass
    PID_FILE.unlink(missing_ok=True)
    READY_FILE.unlink(missing_ok=True)


# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

def resolve_ref(selector_or_ref):
    """
    Resolve a ref (e.g., 'e5') to a selector, or return the selector as-is.
    """
    if selector_or_ref and selector_or_ref.startswith('e') and selector_or_ref[1:].isdigit():
        # It's a ref, look it up
        return _ref_map.get(selector_or_ref, selector_or_ref)
    return selector_or_ref


def get_snapshot_yaml():
    """Get a quick snapshot in YAML format for inclusion in action results."""
    try:
        # Wait briefly for page to stabilize after action
        _page.wait_for_load_state("domcontentloaded", timeout=5000)
        result = handle_snapshot({"format": "yaml"})
        if result.get("success"):
            return result["result"].get("snapshot", "")
        return ""
    except Exception as e:
        return f"[Snapshot error: {e}]"


# =============================================================================
# COMMAND HANDLERS
# =============================================================================

def handle_navigate(args):
    _page.goto(args["url"], wait_until="networkidle", timeout=30000)
    result = {"success": True, "result": f"Navigated to {args['url']}"}

    # Include snapshot if requested
    if args.get("snapshot", True):
        result["snapshot"] = get_snapshot_yaml()

    return result


def handle_click(args):
    click_opts = {}
    if args.get("double"):
        click_opts["click_count"] = 2
    if args.get("button"):
        click_opts["button"] = args["button"]
    if args.get("modifiers"):
        click_opts["modifiers"] = args["modifiers"]

    # Support both 'selector' and 'ref' arguments
    selector = args.get("selector") or args.get("ref")
    selector = resolve_ref(selector)

    _page.click(selector, **click_opts)
    result = {"success": True, "result": f"Clicked: {selector}"}

    # Include snapshot if requested (default: True)
    if args.get("snapshot", True):
        result["snapshot"] = get_snapshot_yaml()

    return result


def handle_type(args):
    # Support both 'selector' and 'ref' arguments
    selector = args.get("selector") or args.get("ref")
    selector = resolve_ref(selector)

    if args.get("slowly"):
        _page.type(selector, args["text"], delay=100)
    else:
        _page.fill(selector, args["text"])

    if args.get("submit"):
        _page.press(selector, "Enter")

    result = {"success": True, "result": f"Typed into {selector}"}

    # Include snapshot if requested (default: True)
    if args.get("snapshot", True):
        result["snapshot"] = get_snapshot_yaml()

    return result


def handle_fill_form(args):
    fields = json.loads(args["fields_json"])
    filled = []

    for field in fields:
        selector = field.get("selector") or field.get("ref")
        selector = resolve_ref(selector)
        value = field.get("value")
        field_type = field.get("type", "text")

        if field_type == "checkbox":
            if value:
                _page.check(selector)
            else:
                _page.uncheck(selector)
        elif field_type == "radio":
            _page.click(selector)
        elif field_type == "select":
            _page.select_option(selector, value)
        else:
            _page.fill(selector, str(value))

        filled.append(selector)

    result = {"success": True, "result": f"Filled {len(filled)} fields"}

    # Include snapshot if requested (default: True)
    if args.get("snapshot", True):
        result["snapshot"] = get_snapshot_yaml()

    return result


def handle_select(args):
    selector = args.get("selector") or args.get("ref")
    selector = resolve_ref(selector)
    _page.select_option(selector, args["value"])

    result = {"success": True, "result": f"Selected '{args['value']}'"}
    if args.get("snapshot", True):
        result["snapshot"] = get_snapshot_yaml()
    return result


def handle_hover(args):
    selector = args.get("selector") or args.get("ref")
    selector = resolve_ref(selector)
    _page.hover(selector)

    result = {"success": True, "result": f"Hovering over {selector}"}
    if args.get("snapshot", True):
        result["snapshot"] = get_snapshot_yaml()
    return result


def handle_drag(args):
    _page.drag_and_drop(args["from_selector"], args["to_selector"])
    return {"success": True, "result": "Drag complete"}


def handle_press_key(args):
    _page.keyboard.press(args["key"])
    return {"success": True, "result": f"Pressed key: {args['key']}"}


def handle_upload(args):
    with _page.expect_file_chooser() as fc_info:
        _page.click(args["selector"])
    file_chooser = fc_info.value
    file_chooser.set_files(args["files"])
    return {"success": True, "result": f"Uploaded {len(args['files'])} file(s)"}


def handle_evaluate(args):
    if args.get("selector"):
        element = _page.locator(args["selector"])
        result = element.evaluate(args["code"])
    else:
        result = _page.evaluate(args["code"])
    return {"success": True, "result": result}


def handle_screenshot(args):
    screenshot_opts = {"type": args.get("type", "png")}

    if args.get("fullpage"):
        screenshot_opts["full_page"] = True

    if args.get("output"):
        screenshot_opts["path"] = args["output"]
        if args.get("selector"):
            _page.locator(args["selector"]).screenshot(**screenshot_opts)
        else:
            _page.screenshot(**screenshot_opts)
        return {"success": True, "result": f"Screenshot saved to {args['output']}"}
    else:
        if args.get("selector"):
            data = _page.locator(args["selector"]).screenshot(**screenshot_opts)
        else:
            data = _page.screenshot(**screenshot_opts)
        return {"success": True, "result": {"base64": base64.b64encode(data).decode()}}


def handle_snapshot(args):
    """
    Improved snapshot that:
    - Includes ALL form elements (inputs, selects, textareas, buttons)
    - Adds element refs (e1, e2, etc.) for direct interaction
    - Shows element states (disabled, checked, selected, etc.)
    - Uses cleaner YAML-like output format
    """
    global _ref_map
    _ref_map = {}  # Reset ref map

    snapshot_script = """
    () => {
        let refCounter = 0;
        const refMap = {};

        function getRef(element) {
            const ref = 'e' + (++refCounter);
            // Store selector info for later use
            let selector = '';
            if (element.id) {
                selector = '#' + element.id;
            } else if (element.name) {
                selector = `[name="${element.name}"]`;
            } else {
                // Build a unique selector
                const tag = element.tagName.toLowerCase();
                const text = element.textContent?.trim().slice(0, 30);
                if (text && ['button', 'a', 'label'].includes(tag)) {
                    selector = `${tag}:has-text("${text.replace(/"/g, '\\\\"')}")`;
                } else {
                    selector = `${tag}:nth-of-type(${Array.from(element.parentElement?.children || []).filter(e => e.tagName === element.tagName).indexOf(element) + 1})`;
                }
            }
            refMap[ref] = selector;
            return ref;
        }

        function getStates(element) {
            const states = [];
            const tag = element.tagName.toLowerCase();

            if (element.disabled) states.push('disabled');
            if (element.checked) states.push('checked');
            if (element.selected) states.push('selected');
            if (element.readOnly) states.push('readonly');
            if (element.required) states.push('required');
            if (document.activeElement === element) states.push('focused');
            if (element.getAttribute('aria-expanded') === 'true') states.push('expanded');
            if (element.getAttribute('aria-hidden') === 'true') states.push('hidden');

            return states;
        }

        function formatNode(node, indent = 0) {
            const pad = '  '.repeat(indent);
            let line = pad + '- ';

            // Determine role/type
            const tag = node.tag;
            const role = node.role || tag;

            // Format: role "name" [states] [ref=X]
            if (['input', 'select', 'textarea', 'button', 'a'].includes(tag) || node.role) {
                line += role;
                if (node.name) line += ` "${node.name}"`;
                if (node.states && node.states.length) line += ' [' + node.states.join('] [') + ']';
                if (node.ref) line += ` [ref=${node.ref}]`;
                if (node.value) line += `: "${node.value}"`;
            } else {
                line += tag;
                if (node.name) line += ` "${node.name}"`;
                if (node.ref) line += ` [ref=${node.ref}]`;
            }

            let result = line;
            if (node.children && node.children.length) {
                result += '\\n' + node.children.map(c => formatNode(c, indent + 1)).join('\\n');
            }
            return result;
        }

        function getTree(element, depth = 0) {
            if (depth > 12) return null;
            if (!element || element.nodeType !== 1) return null;

            const tag = element.tagName.toLowerCase();

            // Skip script, style, svg internals, hidden elements
            if (['script', 'style', 'noscript', 'template'].includes(tag)) return null;
            if (element.getAttribute('aria-hidden') === 'true' && depth > 2) return null;

            const role = element.getAttribute('role');
            const ariaLabel = element.getAttribute('aria-label');
            const placeholder = element.getAttribute('placeholder');
            const title = element.getAttribute('title');
            const alt = element.getAttribute('alt');

            // Determine display name
            let name = ariaLabel || alt || title || placeholder || '';
            if (!name && ['button', 'a', 'label', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'span', 'li', 'td', 'th'].includes(tag)) {
                // Get direct text content, not from children
                const directText = Array.from(element.childNodes)
                    .filter(n => n.nodeType === 3)
                    .map(n => n.textContent.trim())
                    .join(' ')
                    .trim();
                name = directText || element.textContent?.trim().slice(0, 60) || '';
            }

            // Is this an interactive/important element?
            const isFormElement = ['input', 'select', 'textarea', 'button'].includes(tag);
            const isLink = tag === 'a' && element.href;
            const isInteractive = isFormElement || isLink ||
                                  role ||
                                  element.hasAttribute('onclick') ||
                                  element.hasAttribute('tabindex');

            const states = getStates(element);

            // Build node
            const node = {
                tag: tag,
            };

            // Add role if different from tag
            if (role) node.role = role;

            // Add ref for interactive elements
            if (isInteractive) {
                node.ref = getRef(element);
            }

            // Add name
            if (name) node.name = name.slice(0, 80);

            // Add states
            if (states.length) node.states = states;

            // Add type-specific attributes
            if (tag === 'input') {
                node.type = element.type || 'text';
                if (element.type !== 'password' && element.value) {
                    node.value = element.value.slice(0, 50);
                }
                if (placeholder) node.placeholder = placeholder;
            }
            if (tag === 'select') {
                const selected = element.options[element.selectedIndex];
                if (selected) node.value = selected.text;
            }
            if (tag === 'textarea' && element.value) {
                node.value = element.value.slice(0, 50);
            }
            if (tag === 'a' && element.href) {
                node.href = element.href.slice(0, 50);
            }
            if (tag === 'img' && element.src) {
                node.src = element.src.slice(0, 50);
            }

            // Get children
            const children = Array.from(element.children)
                .map(child => getTree(child, depth + 1))
                .filter(c => c !== null);

            if (children.length > 0) {
                node.children = children;
            }

            // Include node if: interactive, has name, has children, or is structural
            const structuralTags = ['div', 'section', 'main', 'nav', 'header', 'footer', 'form', 'ul', 'ol', 'li',
                                    'article', 'aside', 'table', 'tbody', 'tr', 'td', 'th', 'fieldset', 'legend'];

            if (isInteractive || name || children.length > 0 || (structuralTags.includes(tag) && children.length > 0)) {
                return node;
            }

            return null;
        }

        const tree = getTree(document.body);

        return {
            url: window.location.href,
            title: document.title,
            tree: tree,
            refMap: refMap,
            yaml: tree ? formatNode(tree) : ''
        };
    }
    """

    snapshot = _page.evaluate(snapshot_script)

    # Store ref map for later use
    _ref_map = snapshot.get("refMap", {})

    # Format output based on args
    output_format = args.get("format", "yaml")

    if output_format == "yaml":
        result = {
            "url": snapshot["url"],
            "title": snapshot["title"],
            "snapshot": snapshot.get("yaml", ""),
            "refCount": len(_ref_map)
        }
    else:
        result = snapshot

    if args.get("output"):
        Path(args["output"]).write_text(json.dumps(result, indent=2))
        return {"success": True, "result": f"Snapshot saved to {args['output']}"}
    else:
        return {"success": True, "result": result}


def handle_resize(args):
    _page.set_viewport_size({"width": args["width"], "height": args["height"]})
    return {"success": True, "result": f"Resized to {args['width']}x{args['height']}"}


def handle_close(args):
    global _browser, _page, _playwright, _running
    if _browser:
        _browser.close()
        _browser = None
        _page = None
    _running = False
    return {"success": True, "result": "Browser closed"}


def handle_back(args):
    _page.go_back()
    return {"success": True, "result": "Navigated back"}


def handle_dialog(args):
    def handle_dialog_event(dialog):
        if args["action"] == "accept":
            if args.get("text"):
                dialog.accept(args["text"])
            else:
                dialog.accept()
        else:
            dialog.dismiss()

    _page.on("dialog", handle_dialog_event)
    return {"success": True, "result": f"Dialog handler set to {args['action']}"}


def handle_wait(args):
    if args.get("text"):
        _page.wait_for_selector(f"text={args['text']}", timeout=args.get("timeout", 30000))
        return {"success": True, "result": f"Found text: {args['text']}"}
    elif args.get("gone"):
        _page.wait_for_selector(f"text={args['gone']}", state="hidden", timeout=args.get("timeout", 30000))
        return {"success": True, "result": f"Text gone: {args['gone']}"}
    elif args.get("time"):
        time.sleep(args["time"])
        return {"success": True, "result": f"Waited {args['time']} seconds"}
    else:
        _page.wait_for_load_state("networkidle")
        return {"success": True, "result": "Page loaded"}


def handle_console(args):
    level = args.get("level", "info")
    levels = {"error": 0, "warning": 1, "info": 2, "debug": 3}
    target_level = levels.get(level, 2)

    filtered = [m for m in _console_messages if levels.get(m["type"], 2) <= target_level]
    return {"success": True, "result": {"messages": filtered[-50:]}}  # Last 50


def handle_network(args):
    include_static = args.get("include_static", False)
    static_ext = ['.js', '.css', '.png', '.jpg', '.jpeg', '.gif', '.svg', '.woff', '.woff2', '.ttf', '.ico']

    if include_static:
        filtered = _network_requests
    else:
        filtered = [r for r in _network_requests if not any(r["url"].lower().endswith(ext) for ext in static_ext)]

    return {"success": True, "result": {"requests": filtered[-50:]}}  # Last 50


def handle_tabs(args):
    global _page
    context = _browser.contexts[0] if _browser.contexts else None
    if not context:
        return {"success": False, "error": "No browser context"}

    action = args["action"]

    if action == "list":
        tabs = [{"index": i, "url": p.url, "title": p.title()} for i, p in enumerate(context.pages)]
        return {"success": True, "result": tabs}

    elif action == "new":
        _page = context.new_page()
        return {"success": True, "result": f"Created new tab (index {len(context.pages) - 1})"}

    elif action == "close":
        if args.get("index") is not None:
            pages = context.pages
            if 0 <= args["index"] < len(pages):
                target = pages[args["index"]]
                target.close()
                if _page == target and context.pages:
                    _page = context.pages[0]
                return {"success": True, "result": f"Closed tab {args['index']}"}
            else:
                return {"success": False, "error": f"Invalid tab index: {args['index']}"}
        else:
            _page.close()
            if context.pages:
                _page = context.pages[0]
            return {"success": True, "result": "Closed current tab"}

    elif action == "select":
        if args.get("index") is not None:
            pages = context.pages
            if 0 <= args["index"] < len(pages):
                _page = pages[args["index"]]
                _page.bring_to_front()
                return {"success": True, "result": f"Selected tab {args['index']}"}
            else:
                return {"success": False, "error": f"Invalid tab index: {args['index']}"}
        else:
            return {"success": False, "error": "Tab index required for select"}


def handle_run_code(args):
    local_vars = {"page": _page, "browser": _browser, "result": None}
    exec(args["code"], {"__builtins__": __builtins__}, local_vars)
    return {"success": True, "result": local_vars.get("result", "Code executed")}


# Command dispatch
HANDLERS = {
    "navigate": handle_navigate,
    "click": handle_click,
    "type": handle_type,
    "fill_form": handle_fill_form,
    "select": handle_select,
    "hover": handle_hover,
    "drag": handle_drag,
    "press_key": handle_press_key,
    "upload": handle_upload,
    "evaluate": handle_evaluate,
    "screenshot": handle_screenshot,
    "snapshot": handle_snapshot,
    "resize": handle_resize,
    "close": handle_close,
    "back": handle_back,
    "dialog": handle_dialog,
    "wait": handle_wait,
    "console": handle_console,
    "network": handle_network,
    "tabs": handle_tabs,
    "run_code": handle_run_code,
}


def main():
    global _running

    # Set up signal handlers
    signal.signal(signal.SIGTERM, handle_signal)
    signal.signal(signal.SIGINT, handle_signal)

    # Create temp directory
    TEMP_DIR.mkdir(parents=True, exist_ok=True)

    # Write PID
    PID_FILE.write_text(str(os.getpid()))

    try:
        # Initialize browser
        init_browser()

        # Signal ready
        READY_FILE.touch()

        # Main loop
        while _running:
            if COMMAND_FILE.exists():
                try:
                    cmd_data = json.loads(COMMAND_FILE.read_text())
                    COMMAND_FILE.unlink()

                    command = cmd_data.get("command")
                    args = cmd_data.get("args", {})

                    handler = HANDLERS.get(command)
                    if handler:
                        try:
                            result = handler(args)
                            write_result(
                                result.get("success", True),
                                result.get("result"),
                                result.get("error"),
                                result.get("snapshot")
                            )
                        except Exception as e:
                            write_result(False, error=str(e))
                    else:
                        write_result(False, error=f"Unknown command: {command}")

                except json.JSONDecodeError as e:
                    write_result(False, error=f"Invalid command JSON: {e}")
                except Exception as e:
                    write_result(False, error=str(e))

            time.sleep(0.05)  # 50ms poll interval

    finally:
        cleanup()


if __name__ == "__main__":
    main()
